// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'menu_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MenuEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionMenuList,
    required TResult Function(String id) getMenu,
    required TResult Function(Menu menu) saveMenu,
    required TResult Function(Menu menu) deleteMenu,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? subscriptionMenuList,
    TResult? Function(String id)? getMenu,
    TResult? Function(Menu menu)? saveMenu,
    TResult? Function(Menu menu)? deleteMenu,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionMenuList,
    TResult Function(String id)? getMenu,
    TResult Function(Menu menu)? saveMenu,
    TResult Function(Menu menu)? deleteMenu,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionMenuList value) subscriptionMenuList,
    required TResult Function(GetMenu value) getMenu,
    required TResult Function(SaveMenu value) saveMenu,
    required TResult Function(DeleteMenu value) deleteMenu,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult? Function(GetMenu value)? getMenu,
    TResult? Function(SaveMenu value)? saveMenu,
    TResult? Function(DeleteMenu value)? deleteMenu,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult Function(GetMenu value)? getMenu,
    TResult Function(SaveMenu value)? saveMenu,
    TResult Function(DeleteMenu value)? deleteMenu,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MenuEventCopyWith<$Res> {
  factory $MenuEventCopyWith(MenuEvent value, $Res Function(MenuEvent) then) =
      _$MenuEventCopyWithImpl<$Res, MenuEvent>;
}

/// @nodoc
class _$MenuEventCopyWithImpl<$Res, $Val extends MenuEvent>
    implements $MenuEventCopyWith<$Res> {
  _$MenuEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SubscriptionMenuListImplCopyWith<$Res> {
  factory _$$SubscriptionMenuListImplCopyWith(_$SubscriptionMenuListImpl value,
          $Res Function(_$SubscriptionMenuListImpl) then) =
      __$$SubscriptionMenuListImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubscriptionMenuListImplCopyWithImpl<$Res>
    extends _$MenuEventCopyWithImpl<$Res, _$SubscriptionMenuListImpl>
    implements _$$SubscriptionMenuListImplCopyWith<$Res> {
  __$$SubscriptionMenuListImplCopyWithImpl(_$SubscriptionMenuListImpl _value,
      $Res Function(_$SubscriptionMenuListImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SubscriptionMenuListImpl
    with DiagnosticableTreeMixin
    implements SubscriptionMenuList {
  const _$SubscriptionMenuListImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MenuEvent.subscriptionMenuList()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'MenuEvent.subscriptionMenuList'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionMenuListImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionMenuList,
    required TResult Function(String id) getMenu,
    required TResult Function(Menu menu) saveMenu,
    required TResult Function(Menu menu) deleteMenu,
  }) {
    return subscriptionMenuList();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? subscriptionMenuList,
    TResult? Function(String id)? getMenu,
    TResult? Function(Menu menu)? saveMenu,
    TResult? Function(Menu menu)? deleteMenu,
  }) {
    return subscriptionMenuList?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionMenuList,
    TResult Function(String id)? getMenu,
    TResult Function(Menu menu)? saveMenu,
    TResult Function(Menu menu)? deleteMenu,
    required TResult orElse(),
  }) {
    if (subscriptionMenuList != null) {
      return subscriptionMenuList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionMenuList value) subscriptionMenuList,
    required TResult Function(GetMenu value) getMenu,
    required TResult Function(SaveMenu value) saveMenu,
    required TResult Function(DeleteMenu value) deleteMenu,
  }) {
    return subscriptionMenuList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult? Function(GetMenu value)? getMenu,
    TResult? Function(SaveMenu value)? saveMenu,
    TResult? Function(DeleteMenu value)? deleteMenu,
  }) {
    return subscriptionMenuList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult Function(GetMenu value)? getMenu,
    TResult Function(SaveMenu value)? saveMenu,
    TResult Function(DeleteMenu value)? deleteMenu,
    required TResult orElse(),
  }) {
    if (subscriptionMenuList != null) {
      return subscriptionMenuList(this);
    }
    return orElse();
  }
}

abstract class SubscriptionMenuList implements MenuEvent {
  const factory SubscriptionMenuList() = _$SubscriptionMenuListImpl;
}

/// @nodoc
abstract class _$$GetMenuImplCopyWith<$Res> {
  factory _$$GetMenuImplCopyWith(
          _$GetMenuImpl value, $Res Function(_$GetMenuImpl) then) =
      __$$GetMenuImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$GetMenuImplCopyWithImpl<$Res>
    extends _$MenuEventCopyWithImpl<$Res, _$GetMenuImpl>
    implements _$$GetMenuImplCopyWith<$Res> {
  __$$GetMenuImplCopyWithImpl(
      _$GetMenuImpl _value, $Res Function(_$GetMenuImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$GetMenuImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetMenuImpl with DiagnosticableTreeMixin implements GetMenu {
  const _$GetMenuImpl(this.id);

  @override
  final String id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MenuEvent.getMenu(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MenuEvent.getMenu'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetMenuImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetMenuImplCopyWith<_$GetMenuImpl> get copyWith =>
      __$$GetMenuImplCopyWithImpl<_$GetMenuImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionMenuList,
    required TResult Function(String id) getMenu,
    required TResult Function(Menu menu) saveMenu,
    required TResult Function(Menu menu) deleteMenu,
  }) {
    return getMenu(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? subscriptionMenuList,
    TResult? Function(String id)? getMenu,
    TResult? Function(Menu menu)? saveMenu,
    TResult? Function(Menu menu)? deleteMenu,
  }) {
    return getMenu?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionMenuList,
    TResult Function(String id)? getMenu,
    TResult Function(Menu menu)? saveMenu,
    TResult Function(Menu menu)? deleteMenu,
    required TResult orElse(),
  }) {
    if (getMenu != null) {
      return getMenu(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionMenuList value) subscriptionMenuList,
    required TResult Function(GetMenu value) getMenu,
    required TResult Function(SaveMenu value) saveMenu,
    required TResult Function(DeleteMenu value) deleteMenu,
  }) {
    return getMenu(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult? Function(GetMenu value)? getMenu,
    TResult? Function(SaveMenu value)? saveMenu,
    TResult? Function(DeleteMenu value)? deleteMenu,
  }) {
    return getMenu?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult Function(GetMenu value)? getMenu,
    TResult Function(SaveMenu value)? saveMenu,
    TResult Function(DeleteMenu value)? deleteMenu,
    required TResult orElse(),
  }) {
    if (getMenu != null) {
      return getMenu(this);
    }
    return orElse();
  }
}

abstract class GetMenu implements MenuEvent {
  const factory GetMenu(final String id) = _$GetMenuImpl;

  String get id;
  @JsonKey(ignore: true)
  _$$GetMenuImplCopyWith<_$GetMenuImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SaveMenuImplCopyWith<$Res> {
  factory _$$SaveMenuImplCopyWith(
          _$SaveMenuImpl value, $Res Function(_$SaveMenuImpl) then) =
      __$$SaveMenuImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Menu menu});

  $MenuCopyWith<$Res> get menu;
}

/// @nodoc
class __$$SaveMenuImplCopyWithImpl<$Res>
    extends _$MenuEventCopyWithImpl<$Res, _$SaveMenuImpl>
    implements _$$SaveMenuImplCopyWith<$Res> {
  __$$SaveMenuImplCopyWithImpl(
      _$SaveMenuImpl _value, $Res Function(_$SaveMenuImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? menu = null,
  }) {
    return _then(_$SaveMenuImpl(
      null == menu
          ? _value.menu
          : menu // ignore: cast_nullable_to_non_nullable
              as Menu,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MenuCopyWith<$Res> get menu {
    return $MenuCopyWith<$Res>(_value.menu, (value) {
      return _then(_value.copyWith(menu: value));
    });
  }
}

/// @nodoc

class _$SaveMenuImpl with DiagnosticableTreeMixin implements SaveMenu {
  const _$SaveMenuImpl(this.menu);

  @override
  final Menu menu;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MenuEvent.saveMenu(menu: $menu)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MenuEvent.saveMenu'))
      ..add(DiagnosticsProperty('menu', menu));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SaveMenuImpl &&
            (identical(other.menu, menu) || other.menu == menu));
  }

  @override
  int get hashCode => Object.hash(runtimeType, menu);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SaveMenuImplCopyWith<_$SaveMenuImpl> get copyWith =>
      __$$SaveMenuImplCopyWithImpl<_$SaveMenuImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionMenuList,
    required TResult Function(String id) getMenu,
    required TResult Function(Menu menu) saveMenu,
    required TResult Function(Menu menu) deleteMenu,
  }) {
    return saveMenu(menu);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? subscriptionMenuList,
    TResult? Function(String id)? getMenu,
    TResult? Function(Menu menu)? saveMenu,
    TResult? Function(Menu menu)? deleteMenu,
  }) {
    return saveMenu?.call(menu);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionMenuList,
    TResult Function(String id)? getMenu,
    TResult Function(Menu menu)? saveMenu,
    TResult Function(Menu menu)? deleteMenu,
    required TResult orElse(),
  }) {
    if (saveMenu != null) {
      return saveMenu(menu);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionMenuList value) subscriptionMenuList,
    required TResult Function(GetMenu value) getMenu,
    required TResult Function(SaveMenu value) saveMenu,
    required TResult Function(DeleteMenu value) deleteMenu,
  }) {
    return saveMenu(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult? Function(GetMenu value)? getMenu,
    TResult? Function(SaveMenu value)? saveMenu,
    TResult? Function(DeleteMenu value)? deleteMenu,
  }) {
    return saveMenu?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult Function(GetMenu value)? getMenu,
    TResult Function(SaveMenu value)? saveMenu,
    TResult Function(DeleteMenu value)? deleteMenu,
    required TResult orElse(),
  }) {
    if (saveMenu != null) {
      return saveMenu(this);
    }
    return orElse();
  }
}

abstract class SaveMenu implements MenuEvent {
  const factory SaveMenu(final Menu menu) = _$SaveMenuImpl;

  Menu get menu;
  @JsonKey(ignore: true)
  _$$SaveMenuImplCopyWith<_$SaveMenuImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteMenuImplCopyWith<$Res> {
  factory _$$DeleteMenuImplCopyWith(
          _$DeleteMenuImpl value, $Res Function(_$DeleteMenuImpl) then) =
      __$$DeleteMenuImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Menu menu});

  $MenuCopyWith<$Res> get menu;
}

/// @nodoc
class __$$DeleteMenuImplCopyWithImpl<$Res>
    extends _$MenuEventCopyWithImpl<$Res, _$DeleteMenuImpl>
    implements _$$DeleteMenuImplCopyWith<$Res> {
  __$$DeleteMenuImplCopyWithImpl(
      _$DeleteMenuImpl _value, $Res Function(_$DeleteMenuImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? menu = null,
  }) {
    return _then(_$DeleteMenuImpl(
      null == menu
          ? _value.menu
          : menu // ignore: cast_nullable_to_non_nullable
              as Menu,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MenuCopyWith<$Res> get menu {
    return $MenuCopyWith<$Res>(_value.menu, (value) {
      return _then(_value.copyWith(menu: value));
    });
  }
}

/// @nodoc

class _$DeleteMenuImpl with DiagnosticableTreeMixin implements DeleteMenu {
  const _$DeleteMenuImpl(this.menu);

  @override
  final Menu menu;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MenuEvent.deleteMenu(menu: $menu)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MenuEvent.deleteMenu'))
      ..add(DiagnosticsProperty('menu', menu));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteMenuImpl &&
            (identical(other.menu, menu) || other.menu == menu));
  }

  @override
  int get hashCode => Object.hash(runtimeType, menu);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteMenuImplCopyWith<_$DeleteMenuImpl> get copyWith =>
      __$$DeleteMenuImplCopyWithImpl<_$DeleteMenuImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionMenuList,
    required TResult Function(String id) getMenu,
    required TResult Function(Menu menu) saveMenu,
    required TResult Function(Menu menu) deleteMenu,
  }) {
    return deleteMenu(menu);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? subscriptionMenuList,
    TResult? Function(String id)? getMenu,
    TResult? Function(Menu menu)? saveMenu,
    TResult? Function(Menu menu)? deleteMenu,
  }) {
    return deleteMenu?.call(menu);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionMenuList,
    TResult Function(String id)? getMenu,
    TResult Function(Menu menu)? saveMenu,
    TResult Function(Menu menu)? deleteMenu,
    required TResult orElse(),
  }) {
    if (deleteMenu != null) {
      return deleteMenu(menu);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionMenuList value) subscriptionMenuList,
    required TResult Function(GetMenu value) getMenu,
    required TResult Function(SaveMenu value) saveMenu,
    required TResult Function(DeleteMenu value) deleteMenu,
  }) {
    return deleteMenu(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult? Function(GetMenu value)? getMenu,
    TResult? Function(SaveMenu value)? saveMenu,
    TResult? Function(DeleteMenu value)? deleteMenu,
  }) {
    return deleteMenu?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionMenuList value)? subscriptionMenuList,
    TResult Function(GetMenu value)? getMenu,
    TResult Function(SaveMenu value)? saveMenu,
    TResult Function(DeleteMenu value)? deleteMenu,
    required TResult orElse(),
  }) {
    if (deleteMenu != null) {
      return deleteMenu(this);
    }
    return orElse();
  }
}

abstract class DeleteMenu implements MenuEvent {
  const factory DeleteMenu(final Menu menu) = _$DeleteMenuImpl;

  Menu get menu;
  @JsonKey(ignore: true)
  _$$DeleteMenuImplCopyWith<_$DeleteMenuImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
